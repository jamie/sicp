; Ben Bitdiddle has invented a test to determine whether the interpreter
; he is faced with is using applicative-order evaluation or normal-order
; evaluation. He defines the following two procedures:
;
; (defn p [] (p))
;
; (defn test [x y] (if (= x 0) 0 y))
;
; Then he evaluations the expression
;
; (test 0 (p))
;
; What behaviour will Ben observe with an interpreter that uses applicative-
; order evaluation? What behaviour will he observe with an interpreter that
; uses normal-order evaluation?  Explain your answer. (Assume that the
; evaluation rule for the special form `if` is the same whether the
; interpreter is using normal or applicative order: The predicate expression
; is evaluated first, and the result determines whether to evaluate the
; consequent or the alternative expression.)

Normal order will translate (test 0 (p)) as so:

    (if (= 0 0) 0 (p)))

The test will return true, so will return 0.

An applicative order translation will instead translate the
call to p first, which will just become itself:

    (test 0 (p))

Then, there's an unbound p again, so we translate it again,
and have an infinite loop in parsing the call.
